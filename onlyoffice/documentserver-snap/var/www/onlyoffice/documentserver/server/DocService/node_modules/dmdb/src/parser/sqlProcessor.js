"use strict";

var __values = this && this.__values || function(r) {
    var t = "function" == typeof Symbol && Symbol.iterator, e = t && r[t], i = 0;
    if (e) return e.call(r);
    if (r && "number" == typeof r.length) return {
        next: function() {
            return r && i >= r.length && (r = void 0), {
                value: r && r[i++],
                done: !r
            };
        }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var lval_1 = require("./lval"), lexer_1 = require("./lexer"), stringUtil_1 = require("../utils/stringUtil"), dbtype_1 = require("../driver/dbtype"), const_1 = require("../desc/const"), bufferUtil_1 = require("../utils/bufferUtil"), numeric_1 = require("../driver/numeric"), error_1 = require("../driver/error"), SQLProcessor = function() {
    function p() {}
    return p.lex = function(r) {
        for (var t, e = new lexer_1.Lexer(r, !1), i = 0, l = new Array(); null != (t = e.yylex()); ) t.position = i++, 
        l.push(t);
        return l;
    }, p.escape = function(r, t) {
        var e, i;
        if (0 === t.length && !r.includes("{")) return r;
        var l = new Map();
        if (0 < t.length) try {
            for (var n = __values(t), a = n.next(); !a.done; a = n.next()) {
                var _ = a.value;
                l.set(_.toLowerCase(), null);
            }
        } catch (r) {
            e = {
                error: r
            };
        } finally {
            try {
                a && !a.done && (i = n.return) && i.call(n);
            } finally {
                if (e) throw e.error;
            }
        }
        for (var s = "", u = new Array(), o = this.lex(r), f = 0; f < o.length; f++) {
            var v, c, b, d = o[f];
            d.type == lval_1.Type.NORMAL ? "{" === d.value ? (v = this.next(o, f + 1)) && v.type == lval_1.Type.NORMAL ? stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "escape") || stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "call") ? u.push(!0) : stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "oj") ? (u.push(!0), 
            v.value = "", v.type = lval_1.Type.WHITESPACE_OR_COMMENT) : stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "d") ? (u.push(!0), 
            v.value = "date") : stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "t") ? (u.push(!0), 
            v.value = "time") : stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "ts") ? (u.push(!0), 
            v.value = "datetime") : stringUtil_1.StringUtil.equalsIgnoreCase(v.value, "fn") ? (u.push(!0), 
            v.value = "", v.type = lval_1.Type.WHITESPACE_OR_COMMENT, (c = p.next(o, v.position + 1)) && c.type == lval_1.Type.NORMAL && stringUtil_1.StringUtil.equalsIgnoreCase(c.value, "database") && (c.value = "cur_database")) : "?" === v.value && (c = p.next(o, v.position + 1)) && c.type == lval_1.Type.NORMAL && stringUtil_1.StringUtil.equalsIgnoreCase(c.value, "=") && (b = p.next(o, c.position + 1)) && b.type == lval_1.Type.NORMAL && stringUtil_1.StringUtil.equalsIgnoreCase(b.value, "call") ? (u.push(!0), 
            b.value = "", b.type = lval_1.Type.WHITESPACE_OR_COMMENT) : (u.push(!1), s += d.value) : (u.push(!1), 
            s += d.value) : "}" === d.value ? 0 < u.length && u.pop() || (s += d.value) : l && l.has(d.value.toLowerCase()) ? s += '"' + stringUtil_1.StringUtil.processDoubleQuoteOfName(d.value.toUpperCase()) + '"' : s += d.value : d.type == lval_1.Type.STRING ? s += "'" + stringUtil_1.StringUtil.processSingleQuoteOfName(d.value) + "'" : s += d.value;
        }
        return s;
    }, p.execOpt = function(r, t, e) {
        var i = "", l = this.lex(r);
        if (!l || 0 === l.length) return r;
        var n = l[0].value;
        if (!(stringUtil_1.StringUtil.equalsIgnoreCase(n, "insert") || stringUtil_1.StringUtil.equalsIgnoreCase(n, "select") || stringUtil_1.StringUtil.equalsIgnoreCase(n, "update") || stringUtil_1.StringUtil.equalsIgnoreCase(n, "delete"))) return r;
        for (var a = 0; a < l.length; a++) {
            var _ = l[a], s = void 0;
            switch (_.type) {
              case lval_1.Type.NULL:
                i += "?", t.push(new OptParameter(null, dbtype_1.DBType.NULL, dbtype_1.DBType.NULL_PREC));
                break;

              case lval_1.Type.INT:
                i += "?";
                try {
                    s = BigInt(_.value);
                } catch (r) {
                    throw error_1.DBError.ECJS_DATA_CONVERTION_ERROR(r + "");
                }
                s <= const_1.Const.INT32_MAX && s >= const_1.Const.INT32_MIN ? t.push(new OptParameter(bufferUtil_1.BufferUtil.s(Number(s)), dbtype_1.DBType.INT, dbtype_1.DBType.INT_PREC)) : t.push(new OptParameter(bufferUtil_1.BufferUtil.o(s), dbtype_1.DBType.BIGINT, dbtype_1.DBType.BIGINT_PREC));
                break;

              case lval_1.Type.DOUBLE:
                if (i += "?", s = parseFloat(_.value), Number.isNaN(s)) throw error_1.DBError.ECJS_DATA_CONVERTION_ERROR();
                t.push(new OptParameter(bufferUtil_1.BufferUtil.d(s), dbtype_1.DBType.DOUBLE, dbtype_1.DBType.DOUBLE_PREC));
                break;

              case lval_1.Type.DECIMAL:
                i += "?", t.push(new OptParameter(numeric_1.Numeric.fromString(_.value, 0, 0).encode(), dbtype_1.DBType.DECIMAL, 0));
                break;

              case lval_1.Type.STRING:
                if (_.value.length > const_1.Const.INT16_MAX) {
                    i += "'" + stringUtil_1.StringUtil.processSingleQuoteOfName(_.value) + "'";
                    break;
                }
                i += "?", t.push(new OptParameter(bufferUtil_1.BufferUtil.b(_.value, e), dbtype_1.DBType.VARCHAR, dbtype_1.DBType.VARCHAR_PREC));
                break;

              case lval_1.Type.HEX_INT:
              default:
                i += _.value;
            }
            0;
        }
        return i;
    }, p.next = function(r, t) {
        for (var e = null, i = t; i < r.length && (e = r[i]).type === lval_1.Type.WHITESPACE_OR_COMMENT; i++) ;
        return e;
    }, p;
}();

exports.SQLProcessor = SQLProcessor;

var OptParameter = function() {
    function r(r, t, e) {
        this.ioType = 0, this.scale = 0, this.bytes = r, this.type = t, this.prec = e;
    }
    return r.prototype.toString = function() {
        return this.bytes ? this.bytes.toString() : "null";
    }, r;
}();

exports.OptParameter = OptParameter;
"use strict";

var __extends = this && this.__extends || function() {
    var i = function(t, s) {
        return (i = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(t, s) {
            t.__proto__ = s;
        } || function(t, s) {
            for (var e in s) s.hasOwnProperty(e) && (t[e] = s[e]);
        })(t, s);
    };
    return function(t, s) {
        function e() {
            this.constructor = t;
        }
        i(t, s), t.prototype = null === s ? Object.create(s) : (e.prototype = s.prototype, 
        new e());
    };
}(), __values = this && this.__values || function(t) {
    var s = "function" == typeof Symbol && Symbol.iterator, e = s && t[s], i = 0;
    if (e) return e.call(t);
    if (t && "number" == typeof t.length) return {
        next: function() {
            return t && i >= t.length && (t = void 0), {
                value: t && t[i++],
                done: !t
            };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var msg_1 = require("./msg"), executeRetInfo_1 = require("../../desc/executeRetInfo"), statement_1 = require("../../driver/statement"), parameter_1 = require("../../desc/parameter"), const_1 = require("../../desc/const"), dbtype_1 = require("../../driver/dbtype"), typeDescriptor_1 = require("../../desc/typeDescriptor"), error_1 = require("../../driver/error"), enums_1 = require("../../desc/enums"), bufferUtil_1 = require("../../utils/bufferUtil"), column_1 = require("../../desc/column"), dm_1 = require("../../dm"), offRowBinder_1 = require("../../convert/offRowBinder"), Execute = function(n) {
    function u(t, s, e, i) {
        var r = this;
        return "number" == typeof s && e instanceof statement_1.Statement ? r = n.call(this, t, s, e, i) || this : s instanceof statement_1.PreparedStatement && e instanceof Array && ((r = n.call(this, t, t.at.execute2 ? msg_1.Msg.ss : msg_1.Msg.es, s, i) || this).ts = s.params, 
        r.rs = e), r;
    }
    return __extends(u, n), u.prototype.te = function() {
        var s, t, e = void 0 === this.ts ? 0 : this.ts.length;
        if (this.er(e, void 0 === this.rs ? 0 : this.rs.length), 0 < e && (this.ns(this.ts), 
        void 0 !== this.rs && 0 < this.rs.length)) try {
            for (var i = __values(this.rs), r = i.next(); !r.done; r = i.next()) {
                var n = r.value;
                this.hs(this.ts, n);
            }
        } catch (t) {
            s = {
                error: t
            };
        } finally {
            try {
                r && !r.done && (t = i.return) && t.call(i);
            } finally {
                if (s) throw s.error;
            }
        }
    }, u.prototype.ee = function() {
        var t = new executeRetInfo_1.ExecuteRetInfo(), s = this.ir, e = s.connection, i = msg_1.Msg.os;
        t.retSqlType = this.mt.r(i), i += const_1.Const.USINT_SIZE;
        var r = this.mt.r(i);
        i += const_1.Const.USINT_SIZE, t.updateCount = this.mt.n(i), i += const_1.Const.DDWORD_SIZE;
        var n = this.mt.oi(i);
        i += const_1.Const.USINT_SIZE, t.rsUpdatable = 0 != this.mt.e(i), i += const_1.Const.BYTE_SIZE;
        var h = this.mt.t(i);
        i += const_1.Const.ULINT_SIZE, t.printLen = this.mt.t(i), i += const_1.Const.ULINT_SIZE;
        var o = -1;
        t.retSqlType === const_1.Const.SQL_TYPE_DML_SELECT || t.retSqlType === const_1.Const.SQL_TYPE_DML_CALL ? (t.rowid = BigInt(0), 
        t.rsBdta = this.mt.e(i) === const_1.Const.RS_BDTA, i += const_1.Const.BYTE_SIZE, 
        o = this.mt.r(i), i += const_1.Const.USINT_SIZE, i += 5) : (t.rowid = this.mt.n(i), 
        i += const_1.Const.DDWORD_SIZE), t.execId = this.mt.t(i), i += const_1.Const.ULINT_SIZE, 
        t.rsCacheOffset = this.mt.t(i), i += const_1.Const.ULINT_SIZE;
        var a = this.mt.e(i);
        i += const_1.Const.BYTE_SIZE;
        var c, _, f = 1 == (1 & a), u = 2 == (2 & a);
        switch (e.trxStatus = this.mt.t(i), e.setTrxFinish(e.trxStatus), i += const_1.Const.ULINT_SIZE, 
        0 < t.printLen && (c = this.mt.en(t.printLen), t.printMsg = bufferUtil_1.BufferUtil.c(c, 0, c.length, e.getServerEncoding())), 
        0 < n && (t.outParamDatas = this.as(n)), t.retSqlType) {
          case const_1.Const.SQL_TYPE_SET_TIME_ZONE:
            e.conn_prop_localTimezone = this.mt.hn();
            break;

          case const_1.Const.SQL_TYPE_DML_SELECT:
            t.hasResultSet = !0, 0 < r && (s.columns = this.cs(r, t.rsBdta)), this._s(t, s.columns.length, h, o);
            break;

          case const_1.Const.SQL_TYPE_DML_CALL:
            (0 < r || 0 < h) && (t.hasResultSet = !0), 0 < r && (s.columns = this.cs(r, t.rsBdta)), 
            this._s(t, s.columns.length, h, o);
            break;

          case const_1.Const.SQL_TYPE_SET_SESS_TRAN:
            e.isoLevel = this.mt.hn(), e.readOnly = 1 == this.mt.un();
            break;

          case const_1.Const.SQL_TYPE_SET_CURSCH:
            e.schema = this.mt.Pn(e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_EXPLAIN:
            t.explain = this.mt.Pn(e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DML_INSERT:
          case const_1.Const.SQL_TYPE_DML_UPDATE:
          case const_1.Const.SQL_TYPE_DML_DELETE:
            if (f) {
                for (var v = this.mt.N(), p = new Array(v), y = 0; y < v; y++) p[y] = Number(this.mt.Un());
                t.updateCounts = p;
            }
            if (u) for (var b = this.mt.N(), y = 0; y < b; y++) this.mt.Un(); else t.updateCount, 
            BigInt(1);
            this.fs == error_1.DBError.EC_BP_WITH_ERROR().errCode && (t.batchErrors = this.us(t.updateCounts));
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_DATEFMT:
            _ = this.mt.sn(), e.formatDate = this.mt.xn(_, e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_DTFMT:
            _ = this.mt.sn(), e.formatTimestamp = this.mt.xn(_, e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_DTTZFMT:
            _ = this.mt.sn(), e.formatTimestampTZ = this.mt.xn(_, e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_TIMEFMT:
            _ = this.mt.sn(), e.formatTime = this.mt.xn(_, e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_TIMETZFMT:
            _ = this.mt.sn(), e.formatTimeTZ = this.mt.xn(_, e.getServerEncoding());
            break;

          case const_1.Const.SQL_TYPE_DDL_ALTSESS_DATE_LANGUAGE:
            e.oracleDateLanguage = this.mt.sn();
        }
        return t;
    }, u.prototype.er = function(t, s) {
        var e = this.ir, i = msg_1.Msg.os;
        i += this.mt.l(i, this.vs.at.conn_prop_autoCommit ? 1 : 0), i += this.mt.w(i, t), 
        i += this.mt.l(i, 1), i += this.mt.U(i, BigInt(s)), i += this.mt.U(i, BigInt(e.cursorUpdateRow)), 
        i += this.mt.U(i, e.maxRows <= 0 || e.connection.conn_prop_enRsCache ? BigInt(const_1.Const.INT64_MAX) : BigInt(e.maxRows)), 
        i += this.mt.l(i, 1);
        var r = this.vs.at.conn_prop_continueBatchOnError ? 1 : 0;
        try {
            this.ir.execOpts.batchErrors && (r = 1);
        } catch (t) {}
        i += this.mt.l(i, r), i += this.mt.l(i, 0), i += this.mt.l(i, 0), i += this.mt.v(i, 0 === e.queryTimeout ? -1 : e.queryTimeout), 
        i += this.mt.v(i, e.connection.conn_prop_batchAllowMaxErrors), this.mt.l(i, e.innerExec ? 1 : 0);
    }, u.prototype.ns = function(t) {
        var r = this;
        t.forEach(function(t) {
            t.type === dbtype_1.DBType.CURSOR && t.ioType === parameter_1.Parameter.IO_TYPE_OUT ? r.mt.In(parameter_1.Parameter.IO_TYPE_INOUT) : r.mt.In(t.ioType), 
            r.mt.q(t.type);
            var s = t.prec, e = t.scale, i = t.typeDescriptor;
            switch (t.type) {
              case dbtype_1.DBType.ARRAY:
              case dbtype_1.DBType.SARRAY:
                s = typeDescriptor_1.TypeDescriptor.getPackArraySize(i);
                break;

              case dbtype_1.DBType.PLTYPE_RECORD:
                s = typeDescriptor_1.TypeDescriptor.getPackRecordSize(i);
                break;

              case dbtype_1.DBType.CLASS:
                s = typeDescriptor_1.TypeDescriptor.getPackClassSize(i);
                break;

              case dbtype_1.DBType.BLOB:
                dbtype_1.DBType.isComplexType(t.type, t.scale) && 4 == (s = i.getObjId()) && (s = i.getOuterId());
            }
            switch (r.mt.q(s), r.mt.q(e), t.type) {
              case dbtype_1.DBType.ARRAY:
              case dbtype_1.DBType.SARRAY:
                typeDescriptor_1.TypeDescriptor.packArray(i, r.mt);
                break;

              case dbtype_1.DBType.PLTYPE_RECORD:
                typeDescriptor_1.TypeDescriptor.packRecord(i, r.mt);
                break;

              case dbtype_1.DBType.CLASS:
                typeDescriptor_1.TypeDescriptor.packClass(i, r.mt);
            }
        });
    }, u.prototype.hs = function(t, s) {
        for (var e = 0; e < t.length; e++) {
            var i = t[e], r = s[e];
            if (i.type !== dbtype_1.DBType.CURSOR) {
                if (i.ioType !== parameter_1.Parameter.IO_TYPE_OUT) if (r instanceof Buffer) {
                    if (r.length > const_1.Const.MAX_PARAM_DATA_LEN) throw error_1.DBError.ECJS_DATA_TOO_LONG();
                    this.mt.Qn(r);
                } else if (r === enums_1.ParamDataEnum.NULL) this.mt.Tn(const_1.Const.DATA_NULL_LEN); else if (r === enums_1.ParamDataEnum.OFF_ROW) this.mt.m(0); else if (r instanceof offRowBinder_1.OffRowBinder) this.mt.m(0); else {
                    if (!(r instanceof enums_1.LobCtl)) throw new Error("Bind param data failed by invalid param data type");
                    this.mt.Tn(const_1.Const.DATA_LOB_CTL_LEN), this.mt.qt(r.value);
                }
            } else this.mt.m(const_1.Const.ULINT_SIZE), this.mt.q(i.cursorStmt.handle);
        }
    }, u.prototype.as = function(t) {
        for (var s = new Array(t), e = 0, i = this.ts, r = 0; r < i.length; r++) i[r].ioType !== parameter_1.Parameter.IO_TYPE_INOUT && i[r].ioType !== parameter_1.Parameter.IO_TYPE_OUT || (s[e] = r, 
        e++);
        for (var n, h, o, a = new Array(i.length), r = 0; r < t; r++) h = !1, (n = this.mt.x()) === const_1.Const.DATA_NULL_LEN ? h = !(n = 0) : n === const_1.Const.DATA_FULL_LEN && (n = this.mt.N()), 
        h ? a[s[r]] = null : (o = this.mt.en(n), a[s[r]] = o);
        return a;
    }, u.prototype.cs = function(t, s) {
        for (var e, i, r, n, h = this.vs.at.getServerEncoding(), o = new Array(t), a = 0; a < t; a++) {
            var c = new column_1.Column();
            c.type = this.mt.N(), c.prec = this.mt.N(), c.scale = this.mt.N(), c.nullable = 0 != this.mt.N();
            var _ = this.mt.hn();
            c.lob = 0 != (_ & u.ps), c.identity = 0 != (_ & u.ys), c.readonly = 0 != (_ & u.bs), 
            this.mt.$t(4, !1, !0), this.mt.$t(2, !1, !0), e = this.mt.hn(), i = this.mt.hn(), 
            r = this.mt.hn(), n = this.mt.hn(), c.name = this.mt.xn(e, h), c.typeName = this.mt.xn(i, h), 
            c.tableName = this.mt.xn(r, h), c.schemaName = this.mt.xn(n, h), this.ir.readBaseColName && (c.baseName = this.mt.g(h)), 
            c.lob && (c.lobTabId = this.mt.N(), c.lobColId = this.mt.hn()), o[a] = c;
        }
        for (var f, a = 0; a < t; a++) {
            dbtype_1.DBType.isComplexType(o[a].type, o[a].scale) && ((f = new typeDescriptor_1.TypeDescriptor(this.vs.at)).unpack(this.mt), 
            o[a].typeDescriptor = f);
        }
        return o;
    }, u.prototype._s = function(t, s, e, i) {
        if (0 < e) {
            var r = this.mt.Yt;
            if (!t.rsBdta) {
                for (var n = new Array(e), h = 0; h < e; h++) {
                    n[h] = new Array(s + 1), this.mt.$t(2, !1, !0), n[h][0] = this.mt.en(const_1.Const.LINT64_SIZE), 
                    this.mt.$t(2 * s, !1, !0);
                    for (var o = 1; o < s + 1; ++o) {
                        var a = this.mt.x();
                        a == const_1.Const.REC4_SQL_NULL ? n[h][o] = null : a != const_1.Const.REC4_SQL_FULL ? n[h][o] = this.mt.en(a) : n[h][o] = this.mt.pn();
                    }
                }
                t.rsDatas = n;
            }
            t.rsSizeof = this.mt.Yt - r;
        }
        if (0 < t.rsCacheOffset) {
            for (var c = this.mt.hn(), _ = new Array(c), f = new Array(c), h = 0; h < c; h++) _[h] = BigInt(this.mt.N()), 
            f[h] = this.mt.Un();
            t.tbIds = _, t.tbTss = f;
        }
    }, u.prototype.us = function(t) {
        this.mt.$t(4, !1, !0);
        for (var s = this.mt.N(), e = new Array(), i = 0; i < s; i++) {
            var r = this.mt.N();
            t[r] = dm_1.dmdb.EXEC_MANY_FAIL;
            var n = this.mt.N(), h = this.mt.g(this.vs.at.getServerEncoding());
            e.push("row[" + r + "]:" + n + ", " + h);
        }
        return e;
    }, u.ys = 1, u.ps = 2, u.bs = 4, u.ds = 8, u;
}(msg_1.Msg);

exports.Execute = Execute;
"use strict";

var __awaiter = this && this.__awaiter || function(t, u, c, s) {
    return new (c = c || Promise)(function(r, n) {
        function e(t) {
            try {
                o(s.next(t));
            } catch (t) {
                n(t);
            }
        }
        function i(t) {
            try {
                o(s.throw(t));
            } catch (t) {
                n(t);
            }
        }
        function o(t) {
            var n;
            t.done ? r(t.value) : ((n = t.value) instanceof c ? n : new c(function(t) {
                t(n);
            })).then(e, i);
        }
        o((s = s.apply(t, u || [])).next());
    });
}, __generator = this && this.__generator || function(r, e) {
    var i, o, u, c = {
        label: 0,
        sent: function() {
            if (1 & u[0]) throw u[1];
            return u[1];
        },
        trys: [],
        ops: []
    }, t = {
        next: n(0),
        throw: n(1),
        return: n(2)
    };
    return "function" == typeof Symbol && (t[Symbol.iterator] = function() {
        return this;
    }), t;
    function n(n) {
        return function(t) {
            return function(n) {
                if (i) throw new TypeError("Generator is already executing.");
                for (;c; ) try {
                    if (i = 1, o && (u = 2 & n[0] ? o.return : n[0] ? o.throw || ((u = o.return) && u.call(o), 
                    0) : o.next) && !(u = u.call(o, n[1])).done) return u;
                    switch (o = 0, u && (n = [ 2 & n[0], u.value ]), n[0]) {
                      case 0:
                      case 1:
                        u = n;
                        break;

                      case 4:
                        return c.label++, {
                            value: n[1],
                            done: !1
                        };

                      case 5:
                        c.label++, o = n[1], n = [ 0 ];
                        continue;

                      case 7:
                        n = c.ops.pop(), c.trys.pop();
                        continue;

                      default:
                        if (!(u = 0 < (u = c.trys).length && u[u.length - 1]) && (6 === n[0] || 2 === n[0])) {
                            c = 0;
                            continue;
                        }
                        if (3 === n[0] && (!u || n[1] > u[0] && n[1] < u[3])) {
                            c.label = n[1];
                            break;
                        }
                        if (6 === n[0] && c.label < u[1]) {
                            c.label = u[1], u = n;
                            break;
                        }
                        if (u && c.label < u[2]) {
                            c.label = u[2], c.ops.push(n);
                            break;
                        }
                        u[2] && c.ops.pop(), c.trys.pop();
                        continue;
                    }
                    n = e.call(r, c);
                } catch (t) {
                    n = [ 6, t ], o = 0;
                } finally {
                    i = u = 0;
                }
                if (5 & n[0]) throw n[1];
                return {
                    value: n[0] ? n[1] : void 0,
                    done: !0
                };
            }([ n, t ]);
        };
    }
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var const_1 = require("../desc/const"), bufferArray_1 = require("../utils/bufferArray"), OffRowBinder = function() {
    function t(t, n, r) {
        this.readOver = !1, this.position = 0, this.offRow = !1, this.obj = t, this.encoding = n, 
        this.targetLength = r || const_1.Const.IGNORE_TARGET_LENGTH, this.buffer = new bufferArray_1.BufferArray();
    }
    return t.prototype.init = function() {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    return [ 4, this.read(this.buffer) ];

                  case 1:
                    return t.sent(), this.offRow = this.buffer.length > const_1.Const.PUT_LOB_LEN, [ 2, this ];
                }
            });
        });
    }, t.prototype.getBufferLeaveLen = function() {
        return this.buffer.length;
    }, t.prototype.readFromBuffer = function(t) {
        t.append(this.buffer);
    }, t.READ_LEN = const_1.Const.MAX_BLOB_LEN_PER_MSG, t;
}();

exports.OffRowBinder = OffRowBinder;
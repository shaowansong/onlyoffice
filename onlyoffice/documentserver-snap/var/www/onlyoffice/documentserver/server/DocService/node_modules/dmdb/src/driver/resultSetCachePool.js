"use strict";

var __awaiter = this && this.__awaiter || function(t, u, o, h) {
    return new (o = o || Promise)(function(n, e) {
        function i(t) {
            try {
                s(h.next(t));
            } catch (t) {
                e(t);
            }
        }
        function r(t) {
            try {
                s(h.throw(t));
            } catch (t) {
                e(t);
            }
        }
        function s(t) {
            var e;
            t.done ? n(t.value) : ((e = t.value) instanceof o ? e : new o(function(t) {
                t(e);
            })).then(i, r);
        }
        s((h = h.apply(t, u || [])).next());
    });
}, __generator = this && this.__generator || function(n, i) {
    var r, s, u, o = {
        label: 0,
        sent: function() {
            if (1 & u[0]) throw u[1];
            return u[1];
        },
        trys: [],
        ops: []
    }, t = {
        next: e(0),
        throw: e(1),
        return: e(2)
    };
    return "function" == typeof Symbol && (t[Symbol.iterator] = function() {
        return this;
    }), t;
    function e(e) {
        return function(t) {
            return function(e) {
                if (r) throw new TypeError("Generator is already executing.");
                for (;o; ) try {
                    if (r = 1, s && (u = 2 & e[0] ? s.return : e[0] ? s.throw || ((u = s.return) && u.call(s), 
                    0) : s.next) && !(u = u.call(s, e[1])).done) return u;
                    switch (s = 0, u && (e = [ 2 & e[0], u.value ]), e[0]) {
                      case 0:
                      case 1:
                        u = e;
                        break;

                      case 4:
                        return o.label++, {
                            value: e[1],
                            done: !1
                        };

                      case 5:
                        o.label++, s = e[1], e = [ 0 ];
                        continue;

                      case 7:
                        e = o.ops.pop(), o.trys.pop();
                        continue;

                      default:
                        if (!(u = 0 < (u = o.trys).length && u[u.length - 1]) && (6 === e[0] || 2 === e[0])) {
                            o = 0;
                            continue;
                        }
                        if (3 === e[0] && (!u || e[1] > u[0] && e[1] < u[3])) {
                            o.label = e[1];
                            break;
                        }
                        if (6 === e[0] && o.label < u[1]) {
                            o.label = u[1], u = e;
                            break;
                        }
                        if (u && o.label < u[2]) {
                            o.label = u[2], o.ops.push(e);
                            break;
                        }
                        u[2] && o.ops.pop(), o.trys.pop();
                        continue;
                    }
                    e = i.call(n, o);
                } catch (t) {
                    e = [ 6, t ], s = 0;
                } finally {
                    r = u = 0;
                }
                if (5 & e[0]) throw e[1];
                return {
                    value: e[0] ? e[1] : void 0,
                    done: !0
                };
            }([ e, t ]);
        };
    }
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var statement_1 = require("./statement"), resultSet_1 = require("./resultSet"), ResultSetCachePool = function() {
    function t() {
        this.a = 1;
    }
    return t.removeLast = function() {
        if (0 === this.rsKeyList.length) return 0;
        var t = this.rsKeyList.pop();
        if (!t) return 0;
        var e = this.rsMap.get(t);
        return e ? (this.rsMap.delete(t), e.getDataLen()) : 0;
    }, t.refreshKeyList = function(t) {
        var e = this.rsKeyList.indexOf(t);
        -1 !== e && this.rsKeyList.splice(e, 1), this.rsKeyList.unshift(t);
    }, t.put = function(t, e, n) {
        for (var i = n ? n.rsSizeof : 0, r = 1024 * t.connection.conn_prop_rsCacheSize * 1024; this.totalDataLen + i > r; ) {
            if (0 === this.totalDataLen) return;
            this.totalDataLen -= this.removeLast();
        }
        var s = JSON.stringify(new ResultSetKey(t.connection.guid || "", t.connection.schema || "", e, t));
        this.refreshKeyList(s);
        var u = new ResultSetCache(n);
        this.rsMap.set(s, u), this.totalDataLen += i;
    }, t.get = function(t, e, n, i) {
        var r = JSON.stringify(new ResultSetKey(t, e, n, i)), s = this.rsMap.get(r);
        if (s) {
            if (!s.refreshed(i.connection)) return this.refreshKeyList(r), s;
            this.rsMap.delete(r);
            var u = this.rsKeyList.indexOf(r);
            -1 !== u && this.rsKeyList.splice(u, 1);
        }
    }, t.rsMap = new Map(), t.rsKeyList = new Array(), t.totalDataLen = 0, t;
}();

exports.ResultSetCachePool = ResultSetCachePool;

var ResultSetKey = function() {
    function t(t, e, n, i) {
        this.paramCount = 0, this.dbGuid = t, this.currentSchema = e, this.sql = n, i instanceof statement_1.PreparedStatement && (this.paramCount = i.paramCount, 
        this.paramObjects = i.curRowObjects);
    }
    return t.prototype.equals = function(t) {
        return this.dbGuid === t.dbGuid && this.currentSchema === t.currentSchema && this.sql === t.sql && this.paramCount === t.paramCount;
    }, t;
}(), ResultSetCache = function() {
    function t(t) {
        this.execInfo = t, this.m_TbIds = t.tbIds.slice(), this.m_TbTss = t.tbTss.slice(), 
        this.m_lastCheckTime = Date.now();
    }
    return t.prototype.refreshed = function(i) {
        return __awaiter(this, void 0, void 0, function() {
            var e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    return 0 === i.conn_prop_rsRefreshFreq ? [ 2, !1 ] : this.m_lastCheckTime + 1e3 * i.conn_prop_rsRefreshFreq > Date.now() ? [ 2, !1 ] : [ 4, i.access.K(this.m_TbIds) ];

                  case 1:
                    if (e = t.sent(), this.m_lastCheckTime = Date.now(), e.length !== this.m_TbTss.length) return [ 2, !0 ];
                    for (n = 0; n < e.length; n++) if (this.m_TbTss[n] !== e[n]) return [ 2, !0 ];
                    return [ 2, !1 ];
                }
            });
        });
    }, t.prototype.getResultSet = function(t) {
        var e = this.execInfo.rsDatas, n = e ? e.length : 0;
        0 < t.maxRows && t.maxRows < n && (e = e.slice(0, Number(t.maxRows)));
        var i = new resultSet_1.ResultSet(t, t.columns, t.execInfo, e);
        return i.id = 1, i;
    }, t.prototype.getDataLen = function() {
        return this.execInfo.rsSizeof;
    }, t;
}();
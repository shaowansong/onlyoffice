"use strict";

var __awaiter = this && this.__awaiter || function(r, c, s, u) {
    return new (s = s || Promise)(function(e, t) {
        function n(r) {
            try {
                i(u.next(r));
            } catch (r) {
                t(r);
            }
        }
        function o(r) {
            try {
                i(u.throw(r));
            } catch (r) {
                t(r);
            }
        }
        function i(r) {
            var t;
            r.done ? e(r.value) : ((t = r.value) instanceof s ? t : new s(function(r) {
                r(t);
            })).then(n, o);
        }
        i((u = u.apply(r, c || [])).next());
    });
}, __generator = this && this.__generator || function(e, n) {
    var o, i, c, s = {
        label: 0,
        sent: function() {
            if (1 & c[0]) throw c[1];
            return c[1];
        },
        trys: [],
        ops: []
    }, r = {
        next: t(0),
        throw: t(1),
        return: t(2)
    };
    return "function" == typeof Symbol && (r[Symbol.iterator] = function() {
        return this;
    }), r;
    function t(t) {
        return function(r) {
            return function(t) {
                if (o) throw new TypeError("Generator is already executing.");
                for (;s; ) try {
                    if (o = 1, i && (c = 2 & t[0] ? i.return : t[0] ? i.throw || ((c = i.return) && c.call(i), 
                    0) : i.next) && !(c = c.call(i, t[1])).done) return c;
                    switch (i = 0, c && (t = [ 2 & t[0], c.value ]), t[0]) {
                      case 0:
                      case 1:
                        c = t;
                        break;

                      case 4:
                        return s.label++, {
                            value: t[1],
                            done: !1
                        };

                      case 5:
                        s.label++, i = t[1], t = [ 0 ];
                        continue;

                      case 7:
                        t = s.ops.pop(), s.trys.pop();
                        continue;

                      default:
                        if (!(c = 0 < (c = s.trys).length && c[c.length - 1]) && (6 === t[0] || 2 === t[0])) {
                            s = 0;
                            continue;
                        }
                        if (3 === t[0] && (!c || t[1] > c[0] && t[1] < c[3])) {
                            s.label = t[1];
                            break;
                        }
                        if (6 === t[0] && s.label < c[1]) {
                            s.label = c[1], c = t;
                            break;
                        }
                        if (c && s.label < c[2]) {
                            s.label = c[2], s.ops.push(t);
                            break;
                        }
                        c[2] && s.ops.pop(), s.trys.pop();
                        continue;
                    }
                    t = n.call(e, s);
                } catch (r) {
                    t = [ 6, r ], i = 0;
                } finally {
                    o = c = 0;
                }
                if (5 & t[0]) throw t[1];
                return {
                    value: t[0] ? t[1] : void 0,
                    done: !0
                };
            }([ t, r ]);
        };
    }
}, __values = this && this.__values || function(r) {
    var t = "function" == typeof Symbol && Symbol.iterator, e = t && r[t], n = 0;
    if (e) return e.call(r);
    if (r && "number" == typeof r.length) return {
        next: function() {
            return r && n >= r.length && (r = void 0), {
                value: r && r[n++],
                done: !r
            };
        }
    };
    throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var os_1 = require("os"), error_1 = require("../driver/error"), const_1 = require("./const"), EPGroup = function() {
    function r(r, t) {
        this.name = r, this.epList = t, this.epStartPos = t && 0 !== t.length ? Math.floor(Math.random() * t.length) - 1 : -1;
    }
    return r.prototype.connect = function(c) {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, n, o, i;
            return __generator(this, function(r) {
                switch (r.label) {
                  case 0:
                    t = this.getEPSelector(c), n = 1 === this.epList.length ? 1 : c.conn_prop_switchTimes + 1, 
                    o = 0, r.label = 1;

                  case 1:
                    if (!(o < n)) return [ 3, 7 ];
                    r.label = 2;

                  case 2:
                    return r.trys.push([ 2, 4, , 6 ]), [ 4, this.traverseServerList(c, t, 0 === o, o === n - 1) ];

                  case 3:
                    return r.sent(), [ 2, c ];

                  case 4:
                    return i = r.sent(), e = i, [ 4, new Promise(function(r, t) {
                        setTimeout(function() {
                            r();
                        }, c.conn_prop_switchInterval);
                    }) ];

                  case 5:
                    return r.sent(), [ 3, 6 ];

                  case 6:
                    return o++, [ 3, 1 ];

                  case 7:
                    throw e;
                }
            });
        });
    }, r.prototype.traverseServerList = function(h, _, w, l) {
        return __awaiter(this, void 0, void 0, function() {
            var t, e, n, o, i, c, s, u, a, f;
            return __generator(this, function(r) {
                switch (r.label) {
                  case 0:
                    t = _.sortDBList(w), e = "", n = null, r.label = 1;

                  case 1:
                    r.trys.push([ 1, 11, 12, 13 ]), o = __values(t), i = o.next(), r.label = 2;

                  case 2:
                    if (i.done) return [ 3, 10 ];
                    c = i.value, r.label = 3;

                  case 3:
                    return r.trys.push([ 3, 8, , 9 ]), [ 4, c.connect(h) ];

                  case 4:
                    return r.sent(), [ 4, _.checkServerMode(h, l) ];

                  case 5:
                    return r.sent() ? [ 3, 7 ] : [ 4, h.free() ];

                  case 6:
                    throw r.sent(), error_1.DBError.ECJS_INVALID_SERVER_MODE();

                  case 7:
                    return [ 2 ];

                  case 8:
                    return s = r.sent(), n = n || s, e += "[" + c.toString() + "]" + s.message + os_1.EOL, 
                    [ 3, 9 ];

                  case 9:
                    return i = o.next(), [ 3, 2 ];

                  case 10:
                    return [ 3, 13 ];

                  case 11:
                    return u = r.sent(), a = {
                        error: u
                    }, [ 3, 13 ];

                  case 12:
                    try {
                        i && !i.done && (f = o.return) && f.call(o);
                    } finally {
                        if (a) throw a.error;
                    }
                    return [ 7 ];

                  case 13:
                    if (n) throw n;
                    throw new error_1.DBError(error_1.DBError.ECJS_COMMUNICATION_ERROR().errCode, e);
                }
            });
        });
    }, r.prototype.getEPSelector = function(r) {
        if (r.conn_prop_epSelector === EPSelector.TYPE_HEAD_FIRST) return new EPSelector(this.epList.slice(0));
        var t = this.epList.length;
        this.epStartPos = (this.epStartPos + 1) % t;
        for (var e = new Array(t), n = 0; n < t; n++) e[n] = this.epList[(n + this.epStartPos) % t];
        return new EPSelector(e);
    }, r;
}();

exports.EPGroup = EPGroup;

var EPSelector = function() {
    function r(r) {
        this.dbs = r;
    }
    return r.prototype.sortDBList = function(e) {
        return e || this.dbs.sort(function(r, t) {
            return t.getSort(e) - r.getSort(e);
        }), this.dbs;
    }, r.prototype.checkServerMode = function(t, e) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(r) {
                switch (r.label) {
                  case 0:
                    return !t.conn_prop_loginDscCtrl || t.dscControl ? [ 3, 2 ] : [ 4, t.free() ];

                  case 1:
                    throw r.sent(), error_1.DBError.ECJS_INVALID_SERVER_MODE();

                  case 2:
                    return 0 < t.conn_prop_loginStatus && t.svrStat != t.conn_prop_loginStatus ? [ 4, t.free() ] : [ 3, 4 ];

                  case 3:
                    throw r.sent(), error_1.DBError.ECJS_INVALID_SERVER_MODE();

                  case 4:
                    if (e) switch (t.conn_prop_loginMode) {
                      case const_1.Const.LOGIN_MODE_PRIMARY_ONLY:
                        return [ 2, t.svrMode === const_1.Const.SERVER_MODE_PRIMARY ];

                      case const_1.Const.LOGIN_MODE_STANDBY_ONLY:
                        return [ 2, t.svrMode === const_1.Const.SERVER_MODE_STANDBY ];

                      default:
                        return [ 2, !0 ];
                    }
                    switch (t.conn_prop_loginMode) {
                      case const_1.Const.LOGIN_MODE_NORMAL_FIRST:
                        return [ 2, t.svrMode == const_1.Const.SERVER_MODE_NORMAL ];

                      case const_1.Const.LOGIN_MODE_PRIMARY_FIRST:
                      case const_1.Const.LOGIN_MODE_PRIMARY_ONLY:
                        return [ 2, t.svrMode == const_1.Const.SERVER_MODE_PRIMARY ];

                      case const_1.Const.LOGIN_MODE_STANDBY_FIRST:
                      case const_1.Const.LOGIN_MODE_STANDBY_ONLY:
                        return [ 2, t.svrMode == const_1.Const.SERVER_MODE_STANDBY ];
                    }
                    return [ 2, !1 ];
                }
            });
        });
    }, r.TYPE_WELL_DISTRIBUTE = 0, r.TYPE_HEAD_FIRST = 1, r;
}();
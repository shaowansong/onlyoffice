import { Duplex } from "stream";

declare namespace dmdb {
    /**
     * 查询结果集的返回格式——数组
     * @value 4001
     */
    const OUT_FORMAT_ARRAY: number;
    /** 
     * 查询结果集的返回格式——对象
     * @value 4002
     */
    const OUT_FORMAT_OBJECT: number;
    /**
     * 数据类型——BLOB
     * @value 2019
     */
    const BLOB: number;
    /**
     * 数据类型——BUFFER
     * @value 2006
     */
    const BUFFER: number;
    /**
     * 数据类型——CLOB
     * @value 2017
     */
    const CLOB: number;
    /**
     * 数据类型——CURSOR
     * @value 2021
     */
    const CURSOR: number;
    /**
     * 数据类型——DATE
     * @value 2014
     */
    const DATE: number;
    /**
     * 数据类型——DEFAULT
     * @value 0
     */
    const DEFAULT: number;
    /**
     * 数据类型——NUMBER
     * @value 2010
     */
    const NUMBER: number;
    /**
     * 数据类型——STRING
     * @value 2001
     */
    const STRING: number;

    /**
     * 参数绑定方向——绑入
     * @value 3001
     */
    const BIND_IN: number;
    /**
     * 参数绑定方向——双向绑定
     * @value 3002
     */
    const BIND_INOUT: number;
    /**
     * 参数绑定方向——绑出
     * @value 3003
     */
    const BIND_OUT: number;

    /**
     * 连接池状态——打开
     * @value 6000
     */
    const POOL_STATUS_OPEN: number;
    /**
     * 连接池状态——关闭中
     * @value 6001
     */
    const POOL_STATUS_DRAINING: number;
    /**
     * 连接池状态——关闭
     * @value 6002
     */
    const POOL_STATUS_CLOSED: number;

    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 0
     */
    const STMT_TYPE_UNKNOWN: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 1
     */
    const STMT_TYPE_SELECT: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 2
     */
    const STMT_TYPE_UPDATE: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 3
     */
    const STMT_TYPE_DELETE: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 4
     */
    const STMT_TYPE_INSERT: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 5
     */
    const STMT_TYPE_CREATE: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 6
     */
    const STMT_TYPE_DROP: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 7
     */
    const STMT_TYPE_ALTER: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 8
     */
    const STMT_TYPE_BEGIN: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 9
     */
    const STMT_TYPE_DECLARE: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 10
     */
    const STMT_TYPE_CALL: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 15
     */
    const STMT_TYPE_EXPLAIN_PLAN: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 16
     */
    const STMT_TYPE_MERGE: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 17
     */
    const STMT_TYPE_ROLLBACK: number;
    /**
     * connection.getStatementInfo() 返回的语句类型
     * @value 21
     */
    const STMT_TYPE_COMMIT: number;

    /**
     * 是否自动提交
     * @default true
     */
    let autoCommit: boolean;
    /**
     * 是否扩展列信息
     * @default false
     */
    let extendedMetaData: boolean;
    /**
     * 结果返回格式：数组或对象。
     * 取值范围：OUT_FORMAT_ARRAY、OUT_FORMAT_OBJECT
     * @default OUT_FORMAT_ARRAY
     */
    let outFormat: number;
    /**
     * 连接池最大连接数
     * @default 4
     */
    let poolMax: number;
    /**
     * 连接池最小连接数
     * @default 0
     */
    let poolMin: number;
    /**
     * 连接池内连接闲置多久后自动关闭，单位秒，0表示永不关闭
     * @default 60
     */
    let poolTimeout: number;
    /**
     * 获取连接请求等待队列最大长度，-1表示无限制
     * @default 500
     */
    let queueMax: number;
    /**
     * 连接池达到最大连接数后，后续获取连接请求是否进入等待队列
     * @default true
     */
    let queueRequests: boolean;
    /**
     * 进入等待队列的获取连接请求在等待多少毫秒后，认为请求失败，单位毫秒，0表示永久等待
     * @default 60000
     */
    let queueTimeout: number;
    /** 指定结果集中的数据类型以Buffer显示 可选值： BLOB */
    let fetchAsBuffer: number[];
    /** 指定结果集中的数据类型以String显示 可选值： DATE NUMBER BUFFER CLOB */
    let fetchAsString: number[];

    interface BindParameter {
        /** 
         * 绑定方向,取值：BIND_IN / BIND_INOUT / BIND_OUT 
         * @default BIND_IN
         */
        dir?: number;
        /** 参数绑入时的值 */
        val?: any;
    }

    type BindParameters = Record<string, BindParameter | string | number | Date | Buffer | null | undefined> | BindParameter[] | any[];

    interface BindDefinition {
        /** 绑定方向,取值：BIND_IN / BIND_INOUT / BIND_OUT 
         * @default BIND_IN 
         */
        dir?: number;
    }

    interface ExecuteOptions {
        /**
         * 是否扩展执行结果中的MetaData信息
         * @default false
         */
        extendedMetaData?: boolean;
        /**
         * 结果集列以何种JavaScript类型展示，可以覆盖全局设置 fetchAsString和fetchAsBuffer
         *
         * Example:
         *
         *      fetchInfo: {
         *          "COL_NAME_DATE": { type: dmdb.STRING },  // return the date as a string
         *          "COL_NAME_ANY": { type: dmdb.DEFAULT }  // override fetchAsString or fetchAsBuffer
         *      }
         * 
         * type的值可以是：
         * 
         * dmdb.STRING ，对于数字，日期时间，二进制数据，CLOB的结果集列返回String；
         * 
         * dmdb.BUFFER ，对于BLOB的结果集列返回Buffer；
         * 
         * dmdb.DEFAULT ，覆盖dmdb.fetchAsString和dmdb.fetchAsBuffer设置，结果集列返回原始数据；
         */
        fetchInfo?: Record<string, { type: number; }>;
        /**
         * 结果返回格式：数组或对象。
         * 取值范围：OUT_FORMAT_ARRAY、OUT_FORMAT_OBJECT
         * @default OUT_FORMAT_ARRAY
         */
        outFormat?: number;
        /**
         * 是否以结果集方式返回查询结果
         * @default false
         */
        resultSet?: boolean;
    }

    interface ExecuteManyOptions {
        /**
         * 批量执行遇到报错时，是否继续执行
         * @default false
         */
        batchErrors?: boolean;
        /**
         * 定义绑定参数的值和类型
         *
         * 如果按照位置绑定，bindDefs应为数组；如果按照名称绑定，bindDefs应为对象
         */
        bindDefs?:
        | Record<string, BindDefinition>
        | BindDefinition[];
        /**
         * 结果中是否显示批量执行影响行数
         * @default false
         */
        dmlRowCounts?: boolean;
    }

    interface Connection {
        /** 修改指定用户的密码，oldPassword可填空字符串 */
        changePassword(user: string, oldPassword: string, newPassword: string): Promise<void>;
        changePassword(user: string, oldPassword: string, newPassword: string, cb: (error: DBError) => void): void;

        /** 关闭连接 */
        close(): Promise<void>;
        close(cb: (error: DBError) => void): void;

        /** 提交当前事务 */
        commit(): Promise<void>;
        commit(cb: (error: DBError) => void): void;

        /** 新建大字段对象
         * @param type BLOB or CLOB
         */
        createLob(type: number): Promise<Lob>;
        createLob(type: number, cb: (error: DBError, lob: Lob) => void): void;

        /**
         * 执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param bindParams 绑定参数
         * @param options 执行选项
         */
        execute<T>(sql: string, bindParams: BindParameters, options: ExecuteOptions): Promise<Result<T>>;
        execute<T>(sql: string, bindParams: BindParameters, options: ExecuteOptions, cb: (error: DBError, result: Result<T>) => void): void;
        /**
         * 执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param bindParams 绑定参数
         */
        execute<T>(sql: string, bindParams: BindParameters): Promise<Result<T>>;
        execute<T>(sql: string, bindParams: BindParameters, cb: (error: DBError, result: Result<T>) => void): void;
        /**
         * 执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         */
        execute<T>(sql: string): Promise<Result<T>>;
        execute<T>(sql: string, cb: (error: DBError, result: Result<T>) => void): void;

        /**
         * 批量执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param binds 绑定参数
         * @param options 执行选项
         */
        executeMany<T>(sql: string, binds: (Record<string, T> | T[])[], options: ExecuteManyOptions): Promise<Results<T>>;
        executeMany<T>(sql: string, binds: (Record<string, T> | T[])[], options: ExecuteManyOptions, callback: (error: DBError, results: Results<T>) => void): void;
        /**
         * 批量执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param binds 绑定参数
         */
        executeMany<T>(sql: string, binds: (Record<string, T> | T[])[]): Promise<Results<T>>;
        executeMany<T>(sql: string, binds: (Record<string, T> | T[])[], callback: (error: DBError, results: Results<T>) => void): void;
        /**
         * 多次执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param iterations 执行次数
         * @param options 执行选项
         */
        executeMany<T>(sql: string, iterations: number, options: ExecuteManyOptions): Promise<Results<T>>;
        executeMany<T>(sql: string, iterations: number, options: ExecuteManyOptions, callback: (error: DBError, results: Results<T>) => void): void;
        /**
         * 多次执行SQL或PL/SQL语句
         * @param sql SQL or PL/SQL statement
         * @param iterations 执行次数
         */
        executeMany<T>(sql: string, iterations: number): Promise<Results<T>>;
        executeMany<T>(sql: string, iterations: number, callback: (error: DBError, results: Results<T>) => void): void;

        /**
         * 获取语句信息
         * @param sql SQL or PL/SQL statement
         */
        getStatementInfo(sql: string): Promise<StatementInfo>;
        getStatementInfo(sql: string, cb: (error: DBError, statementInfo: StatementInfo) => void): void;

        /**
         * 连接是否连通
         */
        ping(): Promise<void>;
        ping(cb: (error: DBError) => void): void;

        /**
         * 同close方法
         */
        release(): Promise<void>;
        release(cb: (error: DBError) => void): void;

        /** 回滚当前事务 */
        rollback(): Promise<void>;
        rollback(cb: (error: DBError) => void): void;
    }

    interface ConnectionAttributes {
        /** 连接串，与connectionString二选一，connectString更优先，格式 host:port或服务名 */
        connectString?: string;
        /** 连接串，与connectString二选一，connectString更优先，格式 host:port或服务名 */
        connectionString?: string;
        /**
         * 地址重定向，格式：(IP:PORT,IP:PORT)，可配置多个
         * 例如：addressRemap=(192.168.0.1:5236,localhost:5236)，如果连接192.168.0.1:5236，则实际连接到localhost:5236
         * 可以配置多个重定向，如：addressRemap=(localhost:5236,localhost:5237)(localhost:5238,localhost:5239)
         */
        addressRemap?: string;
        /**
         * 在自动提交开关打开时是否允许手动提交回滚
         * @default true
         */
        alwaysAllowCommit?: boolean;
        /** 客户端应用名称 */
        appName?: string;
        /**
         * 是否自动提交
         * @default true
         */
        autoCommit?: boolean;
        /**
         * continueBatchOnError开启时，最大可容错行数，超过则停止执行，但不报错；0表示无限制
         * @default 0
         */
        batchAllowMaxErrors?: number;
        /**
         * 存储过程是否不批量执行
         * @default false
         */
        batchNotOnCall?: boolean;
        /**
         * 批处理模式 1-批量处理 2-一行行执行
         * @default 1
         */
        batchType?: number;
        /**
         * 结果集fetch预取消息buffer大小，单位KB，范围32~65535，0表示按服务器配置
         * @default 0
         */
        bufPrefetch?: number;
        /** 当doSwitch=2，epSelector=1时，用于检测DSC集群节点故障恢复是否成功，取值：DSC */
        cluster?: string;
        /**
         * 批量执行遇到错误时是否继续
         * @default false
         */
        continueBatchOnError?: boolean;
        /**
         * 列名显示是否全部大写
         * @default false
         */
        columnNameUpperCase?: boolean;
        /** 列名大小写显示策略，可选值：'upper' 'lower' */
        columnNameCase?: string;
        /** 兼容其他数据库，'oracle'/1 'mysql'/2 */
        compatibleMode?: string | number;
        /**
         * 是否压缩(0：不压缩；1：完全压缩；2：优化的压缩)
         * @default 0
         */
        compress?: number;
        /**
         * 压缩算法(-1：服务器决定压缩算法；0：ZLIB压缩；1：SNAPPY压缩)
         * @default 0
         */
        compressID?: number;
        /**
         * 连接超时时间,单位ms
         * @default 5000
         */
        connectTimeout?: number;
        /**
         * 连接发生异常或一些特殊场景下连接处理策略。
         * 0：关闭连接；
         * 1：当连接发生异常时自动切换到其他库，无论切换成功还是失败都会报错，用于通知上层应用进行事务执行失败时的相关处理；
         * 2：配合epSelector=1使用，如果服务名列表前面的节点恢复了，将当前连接切换到前面的节点上
         * @default 0
         */
        doSwitch?: number;
        /**
         * 是否开启结果集缓存
         * @default false
         */
        enRsCache?: boolean;
        /**
         * 服务名连接策略 0：依次选取列表中的不同节点建立连接，使得所有连接均匀地分布在各个节点上；
         * 1：选择列表中最前面的节点建立连接，只有当前节点无法建立连接时才会选择下一个节点进行连接
         * @default 0
         */
        epSelector?: number;
        /**
         * 是否处理转义字符
         * @default false
         */
        escapeProcess?: boolean;
        /**
         * 是否以BDTA返回结果集
         * @default false
         */
        isBdtaRS?: boolean;
        /**
         * 大字段获取模式 1：分批缓存到本地, 2：一次将大字段数据缓存到本地
         * @default 1
         */
        lobMode?: number;
        /**
         * 客户端本地时区，单位min，取值范围-720~720
         * @default -new Date().getTimezoneOffset()
         */
        localTimezone?: number;
        /**
         * 日志生成目录
         * @default process.cwd()
         */
        logDir?: string;
        /**
         * 日志刷盘频率，单位s
         * @default 30
         */
        logFlushFreq?: number;
        /** 增强加密所用的dmkey公钥文件路径 */
        loginCertificate?: string;
        /**
         * 服务名连接数据库时只选择dsc control节点的库
         * @default false
         */
        loginDscCtrl?: boolean;
        /**
         * 通信是否加密
         * @default true
         */
        loginEncrypt?: boolean;
        /**
         * 服务名方式连接数据库时只选择模式匹配的库进行连接
         * 0 - PRIMARY = NORMAL > STANDBY
         * 1 - ONLY PRIMARY
         * 2 - ONLY STANDBY
         * 3 - STANDBY > PRIMARY > NORMAL
         * 4 - PRIMARY > NORMAL > STANDBY
         * @default 0
         */
        loginMode?: number;
        /**
         * 服务名方式连接数据库时只选择状态匹配的库进行连接
         * 0 - ALL
         * 3 - ONLY MOUNT
         * 4 - ONLY OPEN
         * 5 - ONLY SUSPEND
         * @default 0
         */
        loginStatus?: number;
        /**
         * 日志级别 'OFF'/0 'ERROR'/1 'WARN'/2 'SQL'/3 'INFO'/4 'DEBUG'/5 'ALL'/9
         * @default 0
         */
        logLevel?: string | number;
        /**
         * 生成的结果集行数限制，超过的截断；0表示无限制
         * @default 0
         */
        maxRows?: number;
        /**
         * mpp登录模式是否本地
         * @default false
         */
        mppLocal?: boolean;
        /** 操作系统名称 */
        osName?: string;
        /**
         * 用户登录密码
         * @default SYSDBA
         */
        password?: string;
        /**
         * 结果集缓存区大小，单位MB，范围1~65536
         * @default 20
         */
        rsCacheSize?: number
        /** 
         * 结果集更新频率，单位:s; 0 表示不检测更新
         * @default 10 
         */
        rsRefreshFreq?: number;
        /**
         * 是否开启读写分离系统高可用模式
         * @default false
         */
        rwHA?: boolean;
        /**
         * 读写分离忽略sql类型，按比例分发到主/备库
         * @default false
         */
        rwIgnoreSql?: boolean;
        /**
         * 读写分离分发百分比
         * @default 25
         */
        rwPercent?: number;
        /**
         * 是否读写分离
         * @default false
         */
        rwSeparate?: boolean;
        /**
         * 读写分离系统备库故障恢复检测频率，单位ms，0表示不恢复
         * @default 1000
         */
        rwStandbyRecoverTime?: number;
        /**
         * 登录schema
         * @default 用户的默认模式
         */
        schema?: string;
        /**
         * 会话超时时间，单位s。0表示无超时限制。
         * @default 0
         */
        sessionTimeout?: number;
        /**
         * 网络通讯超时时间，单位ms。0表示无超时限制。
         * 如果配置了该参数，将导致执行耗时大于超时时间的数据库操作报错
         * @default 0
         */
        socketTimeout?: number;
        /**
         * 句柄池大小
         * @default 15
         */
        stmtPoolSize?: number;
        /**
         * 指定ssl加密证书文件、密钥文件、CA证书文件的目录，
         * 目录内必须包含client-cert.pem、client-key.pem、ca-cert.pem
         */
        sslPath?: string;
        /** 自定义客户端配置文件(dm_svc.conf)的完整路径 */
        svcConfPath?: string;
        /**
         * 服务名连接数据库时，若遍历了服务名中所有库列表都未找到符合条件的库
         * 成功建立连接，等待一定时间再继续下一次遍历，单位ms
         * @default 1000
         */
        switchInterval?: number
        /**
         * 服务名连接数据库时，若未找到符合条件的库成功建立连接，将尝试遍历
         * 服务命中库列表的次数
         * @default 1
         */
        switchTimes?: number;
        /**
         * 登录用户名
         * @default SYSDBA
         */
        user?: string
        /**
         * 用户名重定向，格式：(USER1,USER2)，可配置多个
         * 例如：userRemap=(USER1,USER2)，如果使用USER1用户连接，则实际连接用户为USER2
         * 可以配置多个重定向，如：userRemap=(USER1,USER2)(USER3,USER4)
         */
        userRemap?: string;

        [propName: string]: any;
    }

    interface StatementInfo {
        /** 绑定参数的名称列表 */
        bindNames?: string[];
        /** 列信息 */
        metaData?: Metadata[];
        /** 语句类型，对应 STMT_TYPE_* */
        statementType?: number;
    }

    interface DBError extends Error {
        /** 错误码 */
        errCode: number;
        /** 错误信息 */
        message: string;
    }

    interface Lob extends Duplex {
        /** 大字段类型 BLOB or CLOB */
        readonly type: number;
        /** 关闭Lob */
        close(): Promise<void>;
        close(cb: (error: DBError) => void): void;
        /** 获取lob全部数据 */
        getData(): Promise<string | Buffer>;
        getData(cb: (error: DBError, data: string | Buffer) => void): void;
        /** 获取Lob长度 */
        getLength(): Promise<number>;
        getLength(cb: (error: DBError, length: number) => void): void;

    }

    interface Metadata {
        /** 列名 */
        name: string;
        /** 列类型 */
        dbType?: number;
        /** 列类型名 */
        dbTypeName?: string;
        /** 列数据精度 */
        precision?: number;
        /** 列数据标度 */
        scale?: number;
        /** 列是否可为空 */
        nullable?: boolean;
    }

    interface Pool {
        /** 连接池中正在使用的连接数 */
        readonly connectionsInUse: number;
        /** 连接池中已打开的连接数 */
        readonly connectionsOpen: number;
        /** 连接池别名 */
        readonly poolAlias?: string;
        /** 连接池最大连接数 */
        readonly poolMax: number;
        /** 连接池最小连接数 */
        readonly poolMin: number;
        /** 连接闲置多久后自动关闭，单位秒*/
        readonly poolTimeout: number;
        /** 获取连接请求等待队列最大长度 */
        readonly queueMax: number;
        /** 连接池达到最大连接数后，后续获取连接请求是否进入等待队列 */
        readonly queueRequests: boolean;
        /** 进入等待队列的获取连接请求在等待多少毫秒后，认为请求失败，单位毫秒 */
        readonly queueTimeout: number;
        /** 连接获取前是否验证有效性 */
        readonly testOnBorrow: boolean;
        /** 连接有效性检查使用的SQL语句 */
        readonly validationQuery: string;
        /** 连接池状态，POOL_STATUS_* */
        readonly status: number;

        /**
         * 关闭连接池
         * @param drainTime 池中连接被关闭的最大等待时间
         */
        close(drainTime?: number): Promise<void>;
        close(drainTime: number, cb: (error: DBError) => void): void;
        close(cb: (error: DBError) => void): void;

        /**
         * 从连接池中获取一个空闲的连接；
         * 如果没有空闲的连接，则会新建连接
         */
        getConnection(): Promise<Connection>;
        getConnection(cb: (error: DBError, connection: Connection) => void): void;

        /** 同close方法 */
        terminal(drainTime?: number): Promise<void>;
        terminal(drainTime: number, cb: (error: DBError) => void): void;
        terminal(cb: (error: DBError) => void): void;
    }

    interface PoolAttributes {
        /** 连接串，格式为：dm://username:password@host:port[?prop1=val1[&prop2=val2]] */
        connectString: string,
        /** 连接池别名 */
        poolAlias?: string;
        /** 最大连接数 */
        poolMax?: number;
        /** 最小连接数 */
        poolMin?: number;
        /**
         * 连接池内连接闲置多久后自动关闭，单位秒，0表示永不关闭
         * @default 全局变量 poolTimeout(默认60)
         */
        poolTimeout?: number;
        /**
         * 获取连接请求等待队列最大长度，-1表示无限制
         * @default 全局变量 queueMax(默认500)
         */
        queueMax?: number;
        /**
         * 连接池达到最大连接数后，后续获取连接请求是否进入等待队列
         * @default 全局变量 queueRequests(默认true)
         */
        queueRequests?: boolean;
        /**
         * 进入等待队列的获取连接请求在等待多少毫秒后，认为请求失败，单位毫秒，0表示永久等待
         * @default 全局变量 queueTimeout(默认60000)
         */
        queueTimeout?: number;
        /**
         * 连接获取前是否验证有效性
         * @default false
         */
        testOnBorrow?: boolean;
        /**
         * 连接有效性检查使用的SQL语句，必须至少有一行结果集
         * @default 'select 1;'
         */
        validationQuery?: string;
    }

    /** 语句执行结果 */
    interface Result<T> {
        /** 查询语句的列信息，当且仅当有多个结果集时为二维数组 */
        metaData?: (Metadata | Metadata[])[];
        /** 当有多个结果集时，结果保存在此字段中 */
        implicitResults?: (ResultSet<T> | T[])[];
        /** 绑出参数 Array or Object */
        outBinds?: T;
        /** 查询语句的结果集，当执行选项中的resultSet为true时才会存在 */
        resultSet?: ResultSet<T>;
        /** 查询语句的所有结果行，当执行选项中的resultSet为false时才会存在 */
        rows?: T[];
        /** DML语句影响行数。对于非DML语句(如select、PL/SQL)，此字段为undefined */
        rowsAffected?: number;
    }

    /** 语句批量执行结果 */
    interface Results<T> {
        /** 批量执行错误 */
        batchErrors?: string[];
        /** 批量执行每一次影响的行数，为-1时表示当前批次执行失败。当执行选项中的dmlRowCounts为true时才会存在 */
        dmlRowCounts?: number[];
        /** 绑出参数 */
        outBinds?: T[];
        /** 语句影响行数 */
        rowsAffected?: number;
    }

    /** 可遍历结果集 */
    interface ResultSet<T> {
        /** 关闭结果集 */
        close(): Promise<void>;
        close(cb: (error: DBError) => void): void;
        /** 获取结果集下一行 */
        getRow(): Promise<T>;
        getRow(cb: (error: DBError, row: T) => void): void;
        /** 获取结果集下N行 */
        getRows(numRows: number): Promise<T[]>;
        getRows(numRows: number, cb: (error: DBError, row: T[]) => void): void;
        /** 获取结果集总行数 */
        getRowCount(): Promise<number>;
        getRowCount(cb: (error: DBError, rowCount: number) => void): void;
    }

    /** 创建连接池 */
    function createPool(poolAttributes: PoolAttributes): Promise<Pool>;
    function createPool(poolAttributes: PoolAttributes, cb: (error: DBError, pool: Pool) => void): void;

    /** 创建新连接或从连接池中获取连接 */
    function getConnection(poolAlias: string): Promise<Connection>;
    function getConnection(poolAlias: string, cb: (error: DBError, connection: Connection) => void): void;
    function getConnection(url: string): Promise<Connection>;
    function getConnection(url: string, cb: (error: DBError, connection: Connection) => void): void;
    function getConnection(connAttrs: ConnectionAttributes): Promise<Connection>;
    function getConnection(connAttrs: ConnectionAttributes, cb: (error: DBError, connection: Connection) => void): void;

    /** 根据别名获取连接池对象 */
    function getPool(poolAlias: string): Pool;
}

export = dmdb;
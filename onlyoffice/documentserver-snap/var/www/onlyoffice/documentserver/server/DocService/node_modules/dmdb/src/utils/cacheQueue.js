"use strict";

var __awaiter = this && this.__awaiter || function(t, o, c, s) {
    return new (c = c || Promise)(function(e, n) {
        function r(t) {
            try {
                u(s.next(t));
            } catch (t) {
                n(t);
            }
        }
        function i(t) {
            try {
                u(s.throw(t));
            } catch (t) {
                n(t);
            }
        }
        function u(t) {
            var n;
            t.done ? e(t.value) : ((n = t.value) instanceof c ? n : new c(function(t) {
                t(n);
            })).then(r, i);
        }
        u((s = s.apply(t, o || [])).next());
    });
}, __generator = this && this.__generator || function(e, r) {
    var i, u, o, c = {
        label: 0,
        sent: function() {
            if (1 & o[0]) throw o[1];
            return o[1];
        },
        trys: [],
        ops: []
    }, t = {
        next: n(0),
        throw: n(1),
        return: n(2)
    };
    return "function" == typeof Symbol && (t[Symbol.iterator] = function() {
        return this;
    }), t;
    function n(n) {
        return function(t) {
            return function(n) {
                if (i) throw new TypeError("Generator is already executing.");
                for (;c; ) try {
                    if (i = 1, u && (o = 2 & n[0] ? u.return : n[0] ? u.throw || ((o = u.return) && o.call(u), 
                    0) : u.next) && !(o = o.call(u, n[1])).done) return o;
                    switch (u = 0, o && (n = [ 2 & n[0], o.value ]), n[0]) {
                      case 0:
                      case 1:
                        o = n;
                        break;

                      case 4:
                        return c.label++, {
                            value: n[1],
                            done: !1
                        };

                      case 5:
                        c.label++, u = n[1], n = [ 0 ];
                        continue;

                      case 7:
                        n = c.ops.pop(), c.trys.pop();
                        continue;

                      default:
                        if (!(o = 0 < (o = c.trys).length && o[o.length - 1]) && (6 === n[0] || 2 === n[0])) {
                            c = 0;
                            continue;
                        }
                        if (3 === n[0] && (!o || n[1] > o[0] && n[1] < o[3])) {
                            c.label = n[1];
                            break;
                        }
                        if (6 === n[0] && c.label < o[1]) {
                            c.label = o[1], o = n;
                            break;
                        }
                        if (o && c.label < o[2]) {
                            c.label = o[2], c.ops.push(n);
                            break;
                        }
                        o[2] && c.ops.pop(), c.trys.pop();
                        continue;
                    }
                    n = r.call(e, c);
                } catch (t) {
                    n = [ 6, t ], u = 0;
                } finally {
                    i = o = 0;
                }
                if (5 & n[0]) throw n[1];
                return {
                    value: n[0] ? n[1] : void 0,
                    done: !0
                };
            }([ n, t ]);
        };
    }
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var CacheQueue = function() {
    function t(t, n) {
        this.queue = new Array(0), this.maxSize = t, this.enableLRU = void 0 === n || n;
    }
    return t.prototype.get = function() {
        return this.queue.shift();
    }, t.prototype.put = function(e) {
        return __awaiter(this, void 0, void 0, function() {
            var n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    return this.queue.includes(e) ? [ 2 ] : this.queue.length < this.maxSize ? (this.queue.push(e), 
                    [ 3, 5 ]) : [ 3, 1 ];

                  case 1:
                    return this.enableLRU ? (n = this.get(), [ 4, this.beforeRemove(n) ]) : [ 3, 3 ];

                  case 2:
                    return t.sent(), this.queue.push(e), [ 3, 5 ];

                  case 3:
                    return [ 4, this.beforeRemove(e) ];

                  case 4:
                    t.sent(), t.label = 5;

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.size = function() {
        return this.queue.length;
    }, t.prototype.clear = function() {
        this.queue.splice(0);
    }, t.prototype.beforeRemove = function(t) {
        return __awaiter(this, void 0, void 0, function() {
            return __generator(this, function(t) {
                return [ 2 ];
            });
        });
    }, t;
}();

exports.CacheQueue = CacheQueue;
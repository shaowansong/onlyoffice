"use strict";

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var timestamp_1 = require("../driver/timestamp"), bufferUtil_1 = require("./bufferUtil"), dbtype_1 = require("../driver/dbtype"), error_1 = require("../driver/error"), oracleDateFormat_1 = require("./oracleDateFormat"), DateUtil = function() {
    function c() {}
    return c.encode = function(t, e, m, r) {
        if (dbtype_1.DBType.isLocalTimeZone(e, m) && t[timestamp_1.Timestamp.OFFSET_TIMEZONE] != timestamp_1.Timestamp.INVALID_VALUE && t[timestamp_1.Timestamp.OFFSET_TIMEZONE] != r && c.transformTZ(t, t[timestamp_1.Timestamp.OFFSET_TIMEZONE], r), 
        t[timestamp_1.Timestamp.OFFSET_YEAR] < timestamp_1.Timestamp.MIN_YEAR || t[timestamp_1.Timestamp.OFFSET_YEAR] > timestamp_1.Timestamp.MAX_YEAR) throw error_1.DBError.EC_DATETIME_OVERFLOW();
        var i = t[timestamp_1.Timestamp.OFFSET_YEAR], a = t[timestamp_1.Timestamp.OFFSET_MONTH], s = t[timestamp_1.Timestamp.OFFSET_DAY], _ = t[timestamp_1.Timestamp.OFFSET_HOUR], p = t[timestamp_1.Timestamp.OFFSET_MINUTE], n = t[timestamp_1.Timestamp.OFFSET_SECOND], u = t[timestamp_1.Timestamp.OFFSET_MICROSECOND], f = t[timestamp_1.Timestamp.OFFSET_TIMEZONE] == timestamp_1.Timestamp.INVALID_VALUE ? r : t[timestamp_1.Timestamp.OFFSET_TIMEZONE];
        if ([ i, a, s, _, p, n, u, f ].includes(NaN)) throw error_1.DBError.EC_DATETIME_OVERFLOW();
        var o = null;
        if (e == dbtype_1.DBType.DATE) (o = Buffer.alloc(3))[0] = 255 & i, o[1] = 0 <= i ? i >> 8 | (1 & a) << 7 : i >> 8 & ((1 & a) << 7 | 127), 
        o[2] = (14 & a) >> 1 | s << 3; else if (e == dbtype_1.DBType.DATETIME) (o = Buffer.alloc(8))[0] = 255 & i, 
        o[1] = 0 <= i ? i >> 8 | (1 & a) << 7 : i >> 8 & ((1 & a) << 7 | 127), o[2] = (14 & a) >> 1 | s << 3, 
        o[3] = _ | (7 & p) << 5, o[4] = (56 & p) >> 3 | (31 & n) << 3, o[5] = (32 & n) >> 5 | (127 & u) << 1, 
        o[6] = u >> 7 & 255, o[7] = u >> 15 & 255; else if (e == dbtype_1.DBType.DATETIME_TZ) (o = Buffer.alloc(10))[0] = 255 & i, 
        o[1] = 0 <= i ? i >> 8 | (1 & a) << 7 : i >> 8 & ((1 & a) << 7 | 127), o[2] = (14 & a) >> 1 | s << 3, 
        o[3] = _ | (7 & p) << 5, o[4] = (56 & p) >> 3 | (31 & n) << 3, o[5] = (32 & n) >> 5 | (127 & u) << 1, 
        o[6] = u >> 7 & 255, o[7] = u >> 15 & 255, bufferUtil_1.BufferUtil.y(o, 8, f); else if (e == dbtype_1.DBType.TIME) (o = Buffer.alloc(5))[0] = _ | (7 & p) << 5, 
        o[1] = (56 & p) >> 3 | (31 & n) << 3, o[2] = (32 & n) >> 5 | (127 & u) << 1, o[3] = u >> 7 & 255, 
        o[4] = u >> 15 & 255; else {
            if (e != dbtype_1.DBType.TIME_TZ) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
            (o = Buffer.alloc(7))[0] = _ | (7 & p) << 5, o[1] = (56 & p) >> 3 | (31 & n) << 3, 
            o[2] = (32 & n) >> 5 | (127 & u) << 1, o[3] = u >> 7 & 255, o[4] = u >> 15 & 255, 
            bufferUtil_1.BufferUtil.y(o, 5, f);
        }
        return o;
    }, c.decode = function(t, e, m, r, i, a) {
        var s, _ = e ? this.dmdtDecodeBdta(t) : this.dmdtDecodeFast(t);
        return dbtype_1.DBType.isLocalTimeZone(m, r) && (this.transformTZ(_, a, i), r = dbtype_1.DBType.getLocalTimeZoneScale(m, r)), 
        0 < r && r < 6 && (s = Math.pow(10, 6 - r), _[timestamp_1.Timestamp.OFFSET_MICROSECOND] = _[timestamp_1.Timestamp.OFFSET_MICROSECOND] / s * s), 
        _;
    }, c.encodeByString = function(t, e, m, r, i) {
        var a = new Array(timestamp_1.Timestamp.DT_LEN);
        return this.toDTFromString(t, a), this.encode(a, e, m, r);
    }, c.encodeByDate = function(t, e, m, r, i) {
        var a = this.toDTFromDate(t);
        return this.encode(a, e, m, r);
    }, c.encodeByDateNumber = function(t, e, m, r, i) {
        switch (e) {
          case dbtype_1.DBType.DATETIME:
            var a = this.toDTFromUnix(1e3 * t - timestamp_1.Timestamp.MiSeconds_1900_1970);
            if (a[timestamp_1.Timestamp.OFFSET_YEAR] < timestamp_1.Timestamp.MIN_YEAR || a[timestamp_1.Timestamp.OFFSET_YEAR] > timestamp_1.Timestamp.MAX_YEAR) throw error_1.DBError.EC_DATETIME_OVERFLOW();
            return this.encode(a, e, m, r);

          case dbtype_1.DBType.TIME:
            return a = this.toDTFromUnix(1e3 * t), this.encode(a, e, m, r);

          case dbtype_1.DBType.DATE:
            if ((a = this.toDTFromUnix(24 * t * 60 * 60 * 1e3 - timestamp_1.Timestamp.MiSeconds_1900_1970))[timestamp_1.Timestamp.OFFSET_YEAR] < timestamp_1.Timestamp.MIN_YEAR || a[timestamp_1.Timestamp.OFFSET_YEAR] > timestamp_1.Timestamp.MAX_YEAR) throw error_1.DBError.EC_DATETIME_OVERFLOW();
            return this.encode(a, e, m, r);

          default:
            throw error_1.DBError.ECJS_DATA_CONVERTION_ERROR();
        }
    }, c.toDTFromString = function(t, e) {
        try {
            var m, r, i, a = null, s = null, _ = null, p = null, n = 0, u = 0, f = 0, o = 0, c = 0, h = 0, l = 0, b = void 0, v = void 0, w = 0, d = timestamp_1.Timestamp.INVALID_VALUE, y = 0;
            (t = t.trim()).startsWith("-", 0) && (t = t.substring(1).trim(), w = 1);
            var U = t.split(" ");
            switch (U.length) {
              case 3:
                a = U[0], s = U[1], p = U[2], y = dbtype_1.DBType.DATETIME_TZ;
                break;

              case 2:
                y = 0 < U[0].indexOf(":") ? (s = U[0], p = U[1], dbtype_1.DBType.TIME_TZ) : (a = U[0], 
                s = U[1], dbtype_1.DBType.DATETIME);
                break;

              case 1:
                y = 0 < U[0].indexOf(":") ? (s = U[0], dbtype_1.DBType.TIME) : (a = U[0], dbtype_1.DBType.DATE);
                break;

              default:
                throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
            }
            if (null != a) {
                if (b = a.indexOf("-"), v = a.indexOf("-", b + 1), (b < 0 || v < 0) && (b = t.indexOf("."), 
                v = t.indexOf(".", b + 1)), (b < 0 || v < 0) && (b = t.indexOf("/"), v = t.indexOf("/", b + 1)), 
                !(0 < b && 0 < v && v < a.length - 1)) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                if (n = 1 == w ? 0 - parseInt(a.substring(0, b)) - 1900 : parseInt(a.substring(0, b)) - 1900, 
                u = parseInt(a.substring(b + 1, v)) - 1, f = parseInt(a.substring(v + 1)), !this.checkDate(n + 1900, u + 1, f)) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
            }
            if (null != s) {
                if (m = s.indexOf(":"), r = s.indexOf(":", m + 1), i = s.indexOf(".", r + 1), !(0 < m && 0 < r && r < s.length - 1)) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                if (o = parseInt(s.substring(0, m)), c = parseInt(s.substring(m + 1, r)), 0 < i && i < s.length - 1) {
                    if (h = parseInt(s.substring(r + 1, i)), 9 < (_ = s.substring(i + 1)).length) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                    if (_.charAt(0) < "0" || "9" < _.charAt(0)) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                    _ += "000000000".substring(0, 9 - _.length), l = parseInt(_.substring(0, 6));
                } else {
                    if (0 < i) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                    h = parseInt(s.substring(r + 1));
                }
                if (24 <= o || o < 0 || 60 <= c || c < 0 || 60 <= h || h < 0) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
            }
            if (null != p) {
                var I = !1;
                p.startsWith("-") && (I = !0), (p.startsWith("-") || p.startsWith("+")) && (p = p.substring(1).trim());
                var D = p.split(":"), k = 0, q = 0;
                switch (D.length) {
                  case 2:
                    k = parseInt(D[0].trim()), q = parseInt(D[1].trim());
                    break;

                  case 1:
                    k = parseInt(D[0].trim());
                    break;

                  default:
                    throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                }
                if ((d = 60 * k + q) < 0) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
                if (I && (d *= -1), d <= -780 || 840 < d) throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
            }
            return e[timestamp_1.Timestamp.OFFSET_YEAR] = n + 1900, e[timestamp_1.Timestamp.OFFSET_MONTH] = u + 1, 
            e[timestamp_1.Timestamp.OFFSET_DAY] = 0 == f ? 1 : f, e[timestamp_1.Timestamp.OFFSET_HOUR] = o, 
            e[timestamp_1.Timestamp.OFFSET_MINUTE] = c, e[timestamp_1.Timestamp.OFFSET_SECOND] = h, 
            e[timestamp_1.Timestamp.OFFSET_MICROSECOND] = l, e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = d, 
            y;
        } catch (t) {
            throw error_1.DBError.ECJS_INVALID_DATETIME_FORMAT();
        }
    }, c.toDateFromString = function(t, e) {
        var m = new Array(timestamp_1.Timestamp.DT_LEN);
        return this.toDTFromString(t, m), this.toDateFromDT(m, e);
    }, c.toDTFromDate = function(t) {
        var e = new Array(timestamp_1.Timestamp.DT_LEN);
        return e[timestamp_1.Timestamp.OFFSET_YEAR] = t.getFullYear(), e[timestamp_1.Timestamp.OFFSET_MONTH] = t.getMonth() + 1, 
        e[timestamp_1.Timestamp.OFFSET_DAY] = t.getDate(), e[timestamp_1.Timestamp.OFFSET_HOUR] = t.getHours(), 
        e[timestamp_1.Timestamp.OFFSET_MINUTE] = t.getMinutes(), e[timestamp_1.Timestamp.OFFSET_SECOND] = t.getSeconds(), 
        e[timestamp_1.Timestamp.OFFSET_MICROSECOND] = t.getMilliseconds(), e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = timestamp_1.Timestamp.INVALID_VALUE, 
        e;
    }, c.toDTFromUnix = function(t) {
        return this.toDTFromDate(new Date(t));
    }, c.toDateFromDT = function(t, e) {
        var m = t[timestamp_1.Timestamp.OFFSET_YEAR], r = 0 < t[timestamp_1.Timestamp.OFFSET_MONTH] ? t[timestamp_1.Timestamp.OFFSET_MONTH] : 1, i = 0 < t[timestamp_1.Timestamp.OFFSET_DAY] ? t[timestamp_1.Timestamp.OFFSET_DAY] : 1, a = t[timestamp_1.Timestamp.OFFSET_HOUR], s = t[timestamp_1.Timestamp.OFFSET_MINUTE], _ = t[timestamp_1.Timestamp.OFFSET_SECOND], p = t[timestamp_1.Timestamp.OFFSET_MICROSECOND], n = t[timestamp_1.Timestamp.OFFSET_TIMEZONE] === timestamp_1.Timestamp.INVALID_VALUE ? e : t[timestamp_1.Timestamp.OFFSET_TIMEZONE];
        return new Date(Date.UTC(m, r - 1, i, a, s - n, _, parseInt(p.toString().substr(0, 3))));
    }, c.toStringFromDT = function(t, e, m) {
        return oracleDateFormat_1.OracleDateFormat.format(t, e, m);
    }, c.transformTZ = function(t, e, m) {
        var r = e;
        t[timestamp_1.Timestamp.OFFSET_TIMEZONE] != timestamp_1.Timestamp.INVALID_VALUE && (r = t[timestamp_1.Timestamp.OFFSET_TIMEZONE]), 
        m != r && (t = this.addMinute(t, m - r))[timestamp_1.Timestamp.OFFSET_TIMEZONE] != timestamp_1.Timestamp.INVALID_VALUE && (t[timestamp_1.Timestamp.OFFSET_TIMEZONE] = m);
    }, c.getDaysOfMonth = function(t, e) {
        switch (e) {
          case 1:
          case 3:
          case 5:
          case 7:
          case 8:
          case 10:
          case 12:
            return 31;

          case 4:
          case 6:
          case 9:
          case 11:
            return 30;

          case 2:
            return this.isLeapYear(t) ? 29 : 28;

          default:
            return 0;
        }
    }, c.formatDate = function(t, e) {
        var m = t.getFullYear() + "-" + (t.getMonth() + 1).toString().padStart(2, "0") + "-" + t.getDate().toString().padStart(2, "0");
        return e && (m += " " + t.getHours().toString().padStart(2, "0") + ":" + t.getMinutes().toString().padStart(2, "0") + ":" + t.getSeconds().toString().padStart(2, "0")), 
        m;
    }, c.checkDate = function(t, e, m) {
        return !(9999 < t || t < -4712 || 12 < e || e < 1) && !(this.getDaysOfMonth(t, e) < m || m < 1);
    }, c.isLeapYear = function(t) {
        return t % 4 == 0 && t % 100 != 0 || t % 400 == 0;
    }, c.dmdtDecodeBdta = function(t) {
        var e = new Array(timestamp_1.Timestamp.DT_LEN);
        return e[timestamp_1.Timestamp.OFFSET_YEAR] = bufferUtil_1.BufferUtil.r(t, 0), e[timestamp_1.Timestamp.OFFSET_MONTH] = 255 & t[2], 
        e[timestamp_1.Timestamp.OFFSET_DAY] = 255 & t[3], e[timestamp_1.Timestamp.OFFSET_HOUR] = 255 & t[4], 
        e[timestamp_1.Timestamp.OFFSET_MINUTE] = 255 & t[5], e[timestamp_1.Timestamp.OFFSET_SECOND] = 255 & t[6], 
        e[timestamp_1.Timestamp.OFFSET_MICROSECOND] = (255 & t[7]) + (t[8] << 8) + (t[9] << 16), 
        e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = bufferUtil_1.BufferUtil.r(t, 10), e;
    }, c.dmdtDecodeFast = function(t) {
        var e = new Array(timestamp_1.Timestamp.DT_LEN).fill(0);
        return e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = timestamp_1.Timestamp.INVALID_VALUE, 
        3 == t.length ? (e[timestamp_1.Timestamp.OFFSET_YEAR] = 32767 & bufferUtil_1.BufferUtil.oi(t, 0), 
        9999 < e[timestamp_1.Timestamp.OFFSET_YEAR] && (e[timestamp_1.Timestamp.OFFSET_YEAR] = bufferUtil_1.BufferUtil.cn(bufferUtil_1.BufferUtil.Gn(32768 | e[timestamp_1.Timestamp.OFFSET_YEAR]))), 
        e[timestamp_1.Timestamp.OFFSET_MONTH] = (t[1] >> 7 & 1) + ((7 & t[2]) << 1), e[timestamp_1.Timestamp.OFFSET_DAY] = (248 & t[2]) >> 3 & 31) : t.length < 8 ? (e[timestamp_1.Timestamp.OFFSET_HOUR] = 31 & t[0], 
        e[timestamp_1.Timestamp.OFFSET_MINUTE] = (t[0] >> 5 & 7) + ((7 & t[1]) << 3), e[timestamp_1.Timestamp.OFFSET_SECOND] = (t[1] >> 3 & 31) + ((1 & t[2]) << 5), 
        e[timestamp_1.Timestamp.OFFSET_MICROSECOND] = (t[2] >> 1 & 127) + ((255 & t[3]) << 7) + ((31 & t[4]) << 15), 
        5 < t.length && (e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = bufferUtil_1.BufferUtil.r(t, 5))) : (e[timestamp_1.Timestamp.OFFSET_YEAR] = 32767 & bufferUtil_1.BufferUtil.r(t, 0), 
        9999 < e[timestamp_1.Timestamp.OFFSET_YEAR] && (e[timestamp_1.Timestamp.OFFSET_YEAR] = -32768 | e[timestamp_1.Timestamp.OFFSET_YEAR]), 
        e[timestamp_1.Timestamp.OFFSET_MONTH] = (t[1] >> 7 & 1) + ((7 & t[2]) << 1), e[timestamp_1.Timestamp.OFFSET_DAY] = (248 & t[2]) >> 3 & 31, 
        e[timestamp_1.Timestamp.OFFSET_HOUR] = 31 & t[3], e[timestamp_1.Timestamp.OFFSET_MINUTE] = (t[3] >> 5 & 7) + ((7 & t[4]) << 3), 
        e[timestamp_1.Timestamp.OFFSET_SECOND] = (t[4] >> 3 & 31) + ((1 & t[5]) << 5), e[timestamp_1.Timestamp.OFFSET_MICROSECOND] = (t[5] >> 1 & 127) + ((255 & t[6]) << 7) + ((31 & t[7]) << 15), 
        8 < t.length && (e[timestamp_1.Timestamp.OFFSET_TIMEZONE] = bufferUtil_1.BufferUtil.r(t, 8))), 
        e;
    }, c.addMinute = function(t, e) {
        var m = t[timestamp_1.Timestamp.OFFSET_MINUTE] + e, r = Math.trunc(m / 60);
        return (m %= 60) < 0 && (m += 60, r--), t[timestamp_1.Timestamp.OFFSET_MINUTE] = m, 
        this.addHour(t, r), t;
    }, c.addHour = function(t, e) {
        var m = t[timestamp_1.Timestamp.OFFSET_HOUR] + e, r = Math.trunc(m / 24);
        return (m %= 24) < 0 && (m += 24, r--), t[timestamp_1.Timestamp.OFFSET_HOUR] = m, 
        this.addDay(t, r), t;
    }, c.addDay = function(t, e) {
        for (var m, r = t[timestamp_1.Timestamp.OFFSET_DAY] + e; r > (m = this.getDaysOfMonth(t[timestamp_1.Timestamp.OFFSET_YEAR], t[timestamp_1.Timestamp.OFFSET_MONTH])) || r <= 0; ) this.addMonth(t, m < r ? 1 : -1), 
        r = m < r ? r - m : r + m;
        return t[timestamp_1.Timestamp.OFFSET_DAY] = r, t;
    }, c.addMonth = function(t, e) {
        var m = t[timestamp_1.Timestamp.OFFSET_MONTH] + e, r = Math.trunc(m / 12);
        (m %= 12) < 1 && (m += 12, r--);
        var i = this.getDaysOfMonth(t[timestamp_1.Timestamp.OFFSET_YEAR], m);
        return t[timestamp_1.Timestamp.OFFSET_DAY] > i && (t[timestamp_1.Timestamp.OFFSET_DAY] = i), 
        t[timestamp_1.Timestamp.OFFSET_MONTH] = m, this.addYear(t, r), t;
    }, c.addYear = function(t, e) {
        return t[timestamp_1.Timestamp.OFFSET_YEAR] += e, t;
    }, c;
}();

exports.DateUtil = DateUtil;
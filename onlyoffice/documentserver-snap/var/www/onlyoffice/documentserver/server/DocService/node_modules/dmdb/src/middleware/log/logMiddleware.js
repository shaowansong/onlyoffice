"use strict";

var __awaiter = this && this.__awaiter || function(t, c, a, u) {
    return new (a = a || Promise)(function(e, r) {
        function n(t) {
            try {
                o(u.next(t));
            } catch (t) {
                r(t);
            }
        }
        function i(t) {
            try {
                o(u.throw(t));
            } catch (t) {
                r(t);
            }
        }
        function o(t) {
            var r;
            t.done ? e(t.value) : ((r = t.value) instanceof a ? r : new a(function(t) {
                t(r);
            })).then(n, i);
        }
        o((u = u.apply(t, c || [])).next());
    });
}, __generator = this && this.__generator || function(e, n) {
    var i, o, c, a = {
        label: 0,
        sent: function() {
            if (1 & c[0]) throw c[1];
            return c[1];
        },
        trys: [],
        ops: []
    }, t = {
        next: r(0),
        throw: r(1),
        return: r(2)
    };
    return "function" == typeof Symbol && (t[Symbol.iterator] = function() {
        return this;
    }), t;
    function r(r) {
        return function(t) {
            return function(r) {
                if (i) throw new TypeError("Generator is already executing.");
                for (;a; ) try {
                    if (i = 1, o && (c = 2 & r[0] ? o.return : r[0] ? o.throw || ((c = o.return) && c.call(o), 
                    0) : o.next) && !(c = c.call(o, r[1])).done) return c;
                    switch (o = 0, c && (r = [ 2 & r[0], c.value ]), r[0]) {
                      case 0:
                      case 1:
                        c = r;
                        break;

                      case 4:
                        return a.label++, {
                            value: r[1],
                            done: !1
                        };

                      case 5:
                        a.label++, o = r[1], r = [ 0 ];
                        continue;

                      case 7:
                        r = a.ops.pop(), a.trys.pop();
                        continue;

                      default:
                        if (!(c = 0 < (c = a.trys).length && c[c.length - 1]) && (6 === r[0] || 2 === r[0])) {
                            a = 0;
                            continue;
                        }
                        if (3 === r[0] && (!c || r[1] > c[0] && r[1] < c[3])) {
                            a.label = r[1];
                            break;
                        }
                        if (6 === r[0] && a.label < c[1]) {
                            a.label = c[1], c = r;
                            break;
                        }
                        if (c && a.label < c[2]) {
                            a.label = c[2], a.ops.push(r);
                            break;
                        }
                        c[2] && a.ops.pop(), a.trys.pop();
                        continue;
                    }
                    r = n.call(e, a);
                } catch (t) {
                    r = [ 6, t ], o = 0;
                } finally {
                    i = c = 0;
                }
                if (5 & r[0]) throw r[1];
                return {
                    value: r[0] ? r[1] : void 0,
                    done: !0
                };
            }([ r, t ]);
        };
    }
};

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var logRecord_1 = require("./logRecord"), logger_1 = require("./logger"), svcConf_1 = require("../../desc/svcConf"), logWriter_1 = require("./logWriter"), LogMiddleware = function() {
    function t(t) {
        var r = new svcConf_1.SvcConf();
        r.setAttributes(t);
        var e = new logWriter_1.LogWriter(r.logDir, r.logFlushFreq);
        this.log = new logger_1.Logger(r, e);
    }
    return t.prototype.connection_openConnection = function(e, n, i) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "openConn");
                try {
                    return [ 2, e.connection_openConnection(n, i) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.connection_execute = function(i, o, c, a, u) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    (r = new logRecord_1.LogRecord(o, "execute", c, a, u)).setSql(c), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), this.executeBefore(o.middlewares.logInfo), [ 4, i.connection_execute(o, c, a, u) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.executeAfter(o.middlewares.logInfo, r), this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.connection_executeMany = function(i, o, c, a, u) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    (r = new logRecord_1.LogRecord(o, "executeMany", c, a, u)).setSql(c), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), this.executeBefore(o.middlewares.logInfo), [ 4, i.connection_executeMany(o, c, a, u) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.executeAfter(o.middlewares.logInfo, r), this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.connection_createLob = function(i, o, c) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "createLob", c), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.connection_createLob(o, c) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.connection_close = function(e, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "close");
                try {
                    return [ 2, e.connection_close(n) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.connection_commit = function(e, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "commit");
                try {
                    return [ 2, e.connection_commit(n) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.connection_getStatementInfo = function(i, o, c) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getStatementInfo", c), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.connection_getStatementInfo(o, c) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.connection_rollback = function(e, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "rollback");
                try {
                    return [ 2, e.connection_rollback(n) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.lob_close = function(e, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "close");
                try {
                    return [ 2, e.lob_close(n) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.lob_getData = function(i, o) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getData"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.lob_getData(o) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.lob_getLength = function(i, o) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getLength"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.lob_getLength(o) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.pool_getConnection = function(i, o) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getConnection"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.pool_getConnection(o) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.pool_close = function(e, n, i) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "close", i);
                try {
                    return [ 2, e.pool_close(n, i) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.resultSet_close = function(e, n) {
        return __awaiter(this, void 0, void 0, function() {
            var r;
            return __generator(this, function(t) {
                r = new logRecord_1.LogRecord(n, "close");
                try {
                    return [ 2, e.resultSet_close(n) ];
                } catch (t) {
                    throw r.setError(t), t;
                } finally {
                    this.doLog(r);
                }
                return [ 2 ];
            });
        });
    }, t.prototype.resultSet_getRow = function(i, o) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getRow"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.resultSet_getRow(o) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.resultSet_getRows = function(i, o, c) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getRows"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.resultSet_getRows(o, c) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.resultSet_getRowCount = function(i, o) {
        return __awaiter(this, void 0, void 0, function() {
            var r, e, n;
            return __generator(this, function(t) {
                switch (t.label) {
                  case 0:
                    r = new logRecord_1.LogRecord(o, "getRowCount"), t.label = 1;

                  case 1:
                    return t.trys.push([ 1, 3, 4, 5 ]), [ 4, i.resultSet_getRowCount(o) ];

                  case 2:
                    return e = t.sent(), r.setReturnValue(e), [ 2, e ];

                  case 3:
                    throw n = t.sent(), r.setError(n), n;

                  case 4:
                    return this.doLog(r), [ 7 ];

                  case 5:
                    return [ 2 ];
                }
            });
        });
    }, t.prototype.executeBefore = function(t) {
        this.log.isSqlEnabled() && (t.lastExecuteStartMsec = new Date().getTime());
    }, t.prototype.executeAfter = function(t, r) {
        var e;
        this.log.isSqlEnabled() && (e = new Date().getTime() - t.lastExecuteStartMsec, r.setUsedTime(e));
    }, t.prototype.doLog = function(t) {
        try {
            t.getError() ? this.log.error(t.toString(), t.getError()) : t.getSql() && this.log.isSqlEnabled() ? this.log.sql(t.toString()) : this.log.info(t.toString());
        } catch (t) {
            this.log.error("Log failed!", t);
        }
    }, t;
}();

exports.LogMiddleware = LogMiddleware;
"use strict";

var __extends = this && this.__extends || function() {
    var r = function(e, t) {
        return (r = Object.setPrototypeOf || {
            __proto__: []
        } instanceof Array && function(e, t) {
            e.__proto__ = t;
        } || function(e, t) {
            for (var n in t) t.hasOwnProperty(n) && (e[n] = t[n]);
        })(e, t);
    };
    return function(e, t) {
        function n() {
            this.constructor = e;
        }
        r(e, t), e.prototype = null === t ? Object.create(t) : (n.prototype = t.prototype, 
        new n());
    };
}();

Object.defineProperty(exports, "__esModule", {
    value: !0
});

var const_1 = require("../desc/const"), dbtype_1 = require("./dbtype"), column_1 = require("../desc/column"), connection_1 = require("./connection"), util_1 = require("util"), dateUtil_1 = require("../utils/dateUtil"), Timestamp = function(i) {
    function c(e, t, n) {
        var r = i.call(this) || this;
        if (r.dtype = dbtype_1.DBType.DATETIME, r.scale = 6, e instanceof Buffer && t instanceof column_1.Column && n instanceof connection_1.Connection) switch (r.dt = dateUtil_1.DateUtil.decode(e, t.isBdta, t.type, t.scale, n.conn_prop_localTimezone, n.dbTimezone), 
        r.dtype = t.type, r.scale = dbtype_1.DBType.isLocalTimeZone(t.type, t.scale) ? dbtype_1.DBType.getLocalTimeZoneScale(t.type, t.scale) : t.scale, 
        (r = i.call(this, r.dt[c.OFFSET_YEAR], r.dt[c.OFFSET_MONTH], r.dt[c.OFFSET_DAY], r.dt[c.OFFSET_HOUR], r.dt[c.OFFSET_MINUTE], r.dt[c.OFFSET_SECOND], r.dt[c.OFFSET_MICROSECOND]) || this).oracleDateLanguage = n.oracleDateLanguage, 
        t.type) {
          case dbtype_1.DBType.DATE:
            r.oracleFormatPattern = n.formatDate;
            break;

          case dbtype_1.DBType.TIME:
            r.oracleFormatPattern = n.formatTime;
            break;

          case dbtype_1.DBType.TIME_TZ:
            r.oracleFormatPattern = n.formatTimeTZ;
            break;

          case dbtype_1.DBType.DATETIME:
            r.oracleFormatPattern = n.formatTimestamp;
            break;

          case dbtype_1.DBType.DATETIME_TZ:
            r.oracleFormatPattern = n.formatTimestampTZ;
        } else {
            if (!util_1.isArray(e) || "number" != typeof t || "number" != typeof n) throw new Error("Fatal error occured in Timestamp");
            r.dt = e, r.dtype = t, r.scale = n, r = i.call(this, e[c.OFFSET_YEAR], e[c.OFFSET_MONTH], e[c.OFFSET_DAY], e[c.OFFSET_HOUR], e[c.OFFSET_MINUTE], e[c.OFFSET_SECOND], e[c.OFFSET_MICROSECOND]) || this;
        }
        return r;
    }
    return __extends(c, i), c.MiSeconds_1900_1970 = 22090176e5, c.MAX_YEAR = 9999, c.MIN_YEAR = -4712, 
    c.OFFSET_YEAR = 0, c.OFFSET_MONTH = 1, c.OFFSET_DAY = 2, c.OFFSET_HOUR = 3, c.OFFSET_MINUTE = 4, 
    c.OFFSET_SECOND = 5, c.OFFSET_MICROSECOND = 6, c.OFFSET_TIMEZONE = 7, c.DT_LEN = 8, 
    c.INVALID_VALUE = const_1.Const.INT32_MIN, c;
}(Date);

exports.Timestamp = Timestamp;